# Строки и управление памятью

GtkTextView и GtkTextBuffer имеют функции, которые имеют строковые параметры или возвращают строку.
Знание о строках и управлении памятью полезно для понимания того, как использовать эти функции.

## Строка и память

Строка — это массив символов, который заканчивается '\0'.
Строка не является типом C, таким как char, int, float или double, а массивом символов.
Она ведет себя как строка в других языках.
Поэтому указатель часто называется 'строкой'.

Ниже приведен пример программы.

~~~C
char a[10], *b;

a[0] = 'H';
a[1] = 'e';
a[2] = 'l';
a[3] = 'l';
a[4] = 'o';
a[5] = '\0';

b = a;
/* *b это 'H' */
/* *(++b) это 'e' */
~~~

Массив `a` определен как массив типа `char`, и его размер — десять.
Первые пять элементов — 'H', 'e', 'l', 'l', 'o'.
Это коды символов.
Например, 'H' то же самое, что 0x48 или 72.
Шестой элемент — '\0', который равен нулю и указывает, что последовательность данных заканчивается там.
Массив представляет строку "Hello".

Размер массива — 10, поэтому четыре байта не используются.
Но это нормально.
Они просто игнорируются.
(Если переменная `a` определена вне функций или её класс — static, четыре байта заполняются нулем.
В противном случае, то есть класс — auto или register, они не определены.)

Переменная `b` — указатель на символ.
Ей присваивается `a`, поэтому `b` указывает на первый элемент `a` (символ 'H').
Массив `a` неизменяемый.
Поэтому `a=a+1` вызывает синтаксическую ошибку.

С другой стороны, `b` — это переменная типа указатель, которая изменяемая.
Поэтому `++b`, который увеличивает `b` на единицу, разрешен.


Если указатель равен NULL, он ни на что не указывает.
Поэтому указатель не является строкой.
Это отличается от пустой строки.
Пустая строка — это указатель, указывающий на '\0'.

Есть четыре случая:

- Строка только для чтения
- Строка в статической области памяти
- Строка в стеке
- Строка в памяти, выделенной из области кучи

## Строка только для чтения

Строковый литерал окружен двойными кавычками вот так:

~~~C
char *s;
s = "Hello"
~~~

"Hello" — это строковый литерал, и он только для чтения.
Поэтому следующая программа недопустима.

~~~C
*(s+1) = 'a';
~~~

Результат не определен.
Вероятно, произойдет что-то плохое, например, ошибка сегментации.

ПРИМЕЧАНИЕ: Память литеральной строки выделяется, когда программа компилируется.
Можно увидеть литеральные строки с помощью команды `strings`.

~~~
$ strings src/tvf/a.out
/lib64/ld-linux-x86-64.so.2
cN<5
... ... ...
... ... ...
Once upon a time, there was an old man who was called Taketori-no-Okina. It is a japanese word that means a man whose work is making bamboo baskets.
One day, he went into a hill and found a shining bamboo. "What a mysterious bamboo it is!," he said. He cut it, then there was a small cute baby girl in it. The girl was shining faintly. He thought this baby girl is a gift from Heaven and took her home.
His wife was surprized at his story. They were very happy because they had no children. 
... ... ...
... ... ...
~~~

Это говорит нам, что литеральные строки встроены в бинарные коды программы.

## Строки, определенные как массивы

Если строка определена как массив, она хранится в статической области памяти или в стеке.
Это зависит от класса массива.
Если класс массива — `static`, то он размещается в статической области памяти.
Выделенная память живет в течение всего времени работы программы.
Эта область доступна для записи.

Если класс массива — `auto`, он размещается в стеке.
Если массив определен внутри функции, его класс по умолчанию — `auto`.
Область стека исчезнет, когда функция вернется вызывающей стороне.
Массивы, определенные в стеке, доступны для записи.

~~~C
static char a[] = {'H', 'e', 'l', 'l', 'o', '\0'};

void
print_strings (void) {
  char b[] = "Hello";

  a[1] = 'a'; /* Поскольку массив статический, он доступен для записи. */
  b[1] = 'a'; /* Поскольку массив auto, он доступен для записи. */

  printf ("%s\n", a); /* Hallo */
  printf ("%s\n", b); /* Hallo */
}
~~~

Массив `a` определен вне функций.
Он размещается в статической области памяти, даже если класс `static` опущен.
Компилятор вычисляет количество элементов (шесть) и выделяет шесть байт в статической области памяти.
Затем он копирует данные литеральной строки "Hello" в память.

Массив `b` определен внутри функции, поэтому его класс — `auto`.
Компилятор вычисляет количество элементов в строковом литерале.
Это шесть, потому что он имеет терминатор '\0'.
Компилятор выделяет шесть байт в стеке и копирует литеральную строку "Hello" в память стека.

И `a`, и `b` доступны для записи.

Память выделяется и освобождается программой автоматически, поэтому вам не нужно выделять или освобождать.
Массив `a` живет в течение всего времени жизни программы.
Массив `b` живет, когда функция вызывается, до тех пор, пока функция не вернется вызывающей стороне.

## Строки в области кучи

Вы можете получать, использовать и освобождать память из области кучи.
Стандартная библиотека C предоставляет `malloc` для получения памяти и `free` для возврата памяти.
GLib предоставляет функции `g_new` и `g_free`.
Они похожи на `malloc` и `free`.

~~~C
g_new (struct_type, n_struct)
~~~

`g_new` — это макрос для выделения памяти для массива.

- `struct_type` — это тип элемента массива.
- `n_struct` — это размер массива.
- Возвращаемое значение — указатель на массив.
Его тип — указатель на `struct_type`.

Например,

~~~C
char *s;
s = g_new (char, 10);
/* s указывает на массив char. Размер массива — 10. */

struct tuple {int x, y;} *t;
t = g_new (struct tuple, 5);
/* t указывает на массив struct tuple. */
/* Размер массива — 5. */
~~~

`g_free` освобождает память.

~~~C
void
g_free (gpointer mem);
~~~

Если `mem` равен NULL, `g_free` ничего не делает.
`gpointer` — это тип общего указателя.
Он такой же, как `void *`.
Этот указатель может быть приведен к любому типу указателя.
Наоборот, любой тип указателя может быть приведен к `gpointer`.

~~~C
g_free (s);
/* Освобождает память, выделенную для s. */

g_free (t);
/* Освобождает память, выделенную для t. */
~~~

Если аргумент не указывает на выделенную память, это вызовет ошибку, в частности, ошибку сегментации.

Некоторые функции GLib выделяют память.
Например, `g_strdup` выделяет память и копирует строку, переданную в качестве аргумента.

~~~C
char *s;
s = g_strdup ("Hello");
g_free (s);
~~~

Строковый литерал "Hello" имеет 6 байт, потому что строка имеет '\0' в конце.
`g_strdup` получает 6 байт из области кучи и копирует строку в память.
`s` присваивается начальный адрес памяти.
`g_free` возвращает память в область кучи.

`g_strdup` описан в [GLib API Reference](https://docs.gtk.org/glib/func.strdup.html).
Ниже приведена выдержка из справочника.

> Возвращаемая строка должна быть освобождена с помощью `g_free()`, когда она больше не нужна.

Если вы забудете освободить выделенную память, она останется до конца программы.
Повторное выделение без освобождения вызывает утечку памяти.
Это ошибка и может привести к серьезной проблеме.

## Квалификатор const

Переменная, квалифицированная `const`, может быть назначена для инициализации.
После инициализации никогда не разрешается изменять или освобождать её.

~~~C
const int x = 10; /* инициализация OK. */

x = 20; /* Это незаконно, потому что x квалифицирован const */
~~~

Если функция возвращает тип `const char*`, строка не может быть изменена или освобождена.
Если функция имеет параметр типа `const char *`, это гарантирует, что параметр не изменяется в функции.

~~~C
// Вы никогда не изменяете и не освобождаете возвращаемую строку.
const char*
gtk_label_get_text (
  GtkLabel* self
)

// Str сохраняет себя во время выполнения функции
void
gtk_label_set_text (
  GtkLabel* self,
  const char* str
)
~~~
