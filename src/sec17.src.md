# Меню и действия

## Меню

Пользователи часто используют меню для передачи команд приложению.
Это выглядит так:

![Menu](../image/menu.png){width=5.985cm height=5.055cm}

Существует два типа объектов.

- "File", "Edit", "View", "Cut", "Copy", "Paste" и "Select All".
Они называются "пункты меню" или просто "пункты".
Когда пользователь кликает на один из этих пунктов, происходит какое-то действие.
- Панель меню, подменю, на которое ссылается пункт "Edit", и две секции.
Они называются "меню".
Меню — это упорядоченный список пунктов.
Они похожи на массивы.

![Menu structure](../image/menu_structure.png){width=10.23cm height=3.57cm}

- Панель меню (Menubar) — это меню, которое содержит три пункта: "File", "Edit" и "View".
- Пункт меню с меткой "Edit" имеет ссылку на подменю, которое содержит два пункта.
Эти два пункта не имеют меток.
Каждый пункт ссылается на секцию.
- Первая секция — это меню, которое содержит три пункта: "Cut", "Copy" и "Paste".
- Вторая секция — это меню, которое содержит один пункт: "Select All".

Меню могут создавать сложную структуру благодаря ссылкам пунктов меню.

## GMenuModel, GMenu и GMenuItem

GMenuModel — это абстрактный объект, представляющий меню.
GMenu — это простая реализация GMenuModel и дочерний объект GMenuModel.

    GObject -- GMenuModel -- GMenu

Поскольку GMenuModel является абстрактным объектом, его нельзя инстанцировать.
Следовательно, у него нет функций для создания его экземпляра.
Если вы хотите создать меню, используйте `g_menu_new` для создания экземпляра GMenu.
GMenu наследует все функции GMenuModel.

GMenuItem — это объект, напрямую унаследованный от GObject.
GMenuItem и GMenu (или GMenuModel) не имеют родительско-дочерних отношений.

    GObject -- GMenuModel -- GMenu
    GObject -- GMenuItem

GMenuItem имеет атрибуты.
Один из атрибутов — это метка (label).
Например, на первой диаграмме есть пункт меню с меткой "Edit".
"Cut", "Copy", "Paste" и "Select All" также являются метками пунктов меню.
Другие атрибуты будут объяснены позже.

Некоторые пункты меню имеют ссылку на другое GMenu.
Существует два типа ссылок: подменю (submenu) и секция (section).

GMenuItem можно вставить, добавить в конец или в начало GMenu.
При вставке все атрибуты и значения ссылок копируются и сохраняются в меню.
Сам GMenuItem на самом деле не вставляется.
Поэтому после вставки GMenuItem бесполезен и должен быть освобожден.
То же самое касается добавления в конец или в начало.

Следующий код показывает, как добавить GMenuItem в GMenu.

    GMenu *menu = g_menu_new ();
    GMenuItem *menu_item_quit = g_menu_item_new ("Quit", "app.quit");
    g_menu_append_item (menu, menu_item_quit);
    g_object_unref (menu_item_quit);

## Меню и действие

Один из атрибутов пунктов меню — это действие (action).
Этот атрибут указывает на объект действия.

Существует два объекта действий: GSimpleAction и GPropertyAction.
GSimpleAction используется чаще всего.
И он используется с пунктом меню.
В этом разделе описывается только GSimpleAction.

Действие, соответствующее пункту меню, активируется при клике на пункт меню.
Затем действие испускает сигнал activate.

1. Пункт меню кликается.
2. Соответствующее действие активируется.
3. Действие испускает сигнал.
4. Подключенный обработчик вызывается.


Следующий код является примером.

~~~C
static void
quit_activated(GSimpleAction *action, GVariant *parameter, gpointer app) { ... ... ...}

GSimpleAction *act_quit = g_simple_action_new ("quit", NULL);
g_action_map_add_action (G_ACTION_MAP (app), G_ACTION (act_quit));
g_signal_connect (act_quit, "activate", G_CALLBACK (quit_activated), app);
GMenuItem *menu_item_quit = g_menu_item_new ("Quit", "app.quit");
~~~

- Переменная `menu_item_quit` указывает на пункт меню.
На самом деле это указатель, но мы часто говорим, что `menu_item_quit` *является* пунктом меню.
Он имеет метку "Quit" и связан с действием "app.quit".
"app" — это префикс, а "quit" — имя действия.
Префикс "app" означает, что действие принадлежит экземпляру GtkApplication.
- `act_quit` — это действие.
Оно имеет имя "quit".
Функция `g_simple_action_new` создает действие без состояния.
Таким образом, `act_quit` не имеет состояния.
Значение отсутствия состояния будет объяснено позже.
Аргумент `NULL` означает, что действие не имеет параметра.
Большинство действий не имеют состояния и параметров.
- Действие `act_quit` добавляется к экземпляру GtkApplication с помощью `g_action_map_add_action`.
Следовательно, область видимости действия — приложение.
Префикс `app.quit` указывает на область видимости.
- Сигнал "activate" действия подключается к обработчику `quit_activated`.

Если меню кликнуто, соответствующее действие "quit" будет активировано и испустит сигнал "activate".
Затем будет вызван обработчик `quit_activated`.

## Панель меню

Панель меню и меню являются традиционными.
В последнее время вместо панели меню часто используются кнопки меню, но старый стиль все еще широко используется.

Приложения имеют только одну панель меню.
Если у приложения есть два или более окон с панелями меню, панели меню точно такие же.
Потому что каждое окно ссылается на один и тот же экземпляр панели меню в приложении.

Панель меню приложения обычно не изменяется после установки.
Поэтому уместно установить ее в обработчике "startup".
Потому что обработчик вызывается только один раз в основном экземпляре приложения.

Я думаю, читателям будет полезно понять, как ведут себя приложения.

- Когда приложение запускается впервые, экземпляр называется первичным (primary).
- Первичный экземпляр регистрируется в системе. Если это удается, он испускает сигнал "startup".
- Когда экземпляр активируется, испускается сигнал "activate" или "open".
- Если приложение запускается во второй раз или позже и существует первичный экземпляр, экземпляр называется удаленным (remote).
- Удаленный экземпляр не испускает сигнал "startup".
- Если он пытается испустить сигнал "activate" или "open", сигналы испускаются не на удаленном экземпляре, а на первичном.
- Удаленный экземпляр завершается.

Следовательно, обработчик "activate" или "open" может быть вызван два или более раз.
С другой стороны, обработчик "startup" вызывается один раз.
Поэтому панель меню должна быть установлена в обработчике "startup".

~~~C
static void
app_startup (GApplication *app) {
... ... ...
  gtk_application_set_menubar (GTK_APPLICATION (app), G_MENU_MODEL (menubar));
... ... ...
}
~~~

## Простой пример

Ниже приведен простой пример меню и действий.
Исходный файл `menu1.c` находится в каталоге [src/menu](menu).

@@@include
menu/menu1.c
@@@

- 3-6: `quit_activated` — это обработчик сигнала "activate" действия `act_quit`.
Обработчики сигнала "activate" имеют три параметра.
  1. Экземпляр действия, на котором испускается сигнал.
  2. Параметр.
В этом примере это `NULL`, потому что второй аргумент `g_simple_action_new` (строка 23) равен `NULL`.
Вам не нужно заботиться об этом.
  3. Пользовательские данные.
Это четвертый параметр в `g_signal_connect` (строка 25), который соединяет действие и обработчик.
- 5: Функция `g_application_quit` немедленно завершает приложение.
- 8-17: `app_activate` — это обработчик сигнала "activate" приложения.
- 11-13: Создает GtkApplicationWindow `win`. И устанавливает заголовок и размер по умолчанию.
- 15: Устанавливает для GtkApplicationWindow показ панели меню.
- 16: Показывает окно.
- 19-38: `app_startup` — это обработчик сигнала "startup" приложения.
- 23: Создает GSimpleAction `act_quit`.
Оно не имеет состояния.
Первый аргумент `g_simple_action_new` — это имя действия, а второй аргумент — параметр.
Если вам не нужен параметр, передайте `NULL`.
Следовательно, `act_quit` имеет имя "quit" и не имеет параметра.
- 24: Добавляет действие к GtkApplication `app`.
GtkApplication реализует интерфейс GActionMap и GActionGroup.
GtkApplication (GActionMap) может иметь группу действий, и действия добавляются с помощью функции `g_action_map_add_action`.
Эта функция описана в [Gio API Reference -- g\_action\_map\_add\_action](https://docs.gtk.org/gio/method.ActionMap.add_action.html).
Поскольку это действие принадлежит GtkApplication, его область видимости — "app", и на него ссылаются как на "app.quit", если префикс (область видимости) необходим.
- 25: Подключает сигнал "activate" действия и обработчик `quit_activated`.
- 27-30: Создает экземпляры GMenu и GMenuItem.
`menubar` и `menu` — это GMenu.
`menu_item_menu` и `menu_item_quit` — это GMenuItem.
`menu_item_menu` имеет метку "Menu" и не имеет действия.
`menu_item_quit` имеет метку "Quit" и действие "app.quit".
- 31-32: Добавляет `menu_item_quit` в `menu`.
Как я упоминал ранее, все атрибуты и ссылки копируются и используются для формирования нового пункта в `menu`.
Поэтому после добавления `menu_item_quit` больше не нужен.
Он освобождается с помощью `g_object_unref`.
- 33-34: Устанавливает ссылку подменю в `menu_item_menu` на `menu`.
Затем `menu` больше не нужен и освобождается.
- 35-36: Добавляет `menu_item_menu` в `menubar`.
Затем освобождает `menu_item_menu`.
GMenu и GMenuItem строятся и в конце концов подключаются к переменной `menubar`.
Структура меню показана на диаграмме ниже.
- 38: Панель меню вставляется в приложение.

![menu and action](../image/menu1.png){width=12.555cm height=3.285cm}

## Компиляция

Перейдите в каталог `src/menu`.
Используйте comp для компиляции `menu1.c`.

~~~
$ comp menu1
$ ./a.out
~~~

Затем появится окно.
Кликните на "Menu" на панели меню, затем появится меню.
Кликните на меню "Quit", затем приложение завершится.

![Screenshot of menu1](../image/menu1_screenshot.png){width=6.0cm height=5.115cm}

## Первичный и удаленный экземпляры приложения

Давайте попробуем запустить приложение дважды.
Используйте `&` в командной строке вашей оболочки, тогда приложение запустится параллельно.

~~~
$ ./a.out &
[1] 70969
$ ./a.out
$ 
~~~

Затем появятся два окна.

- Первый `./a.out` вызывает приложение и создается первичный экземпляр.
Он вызывает обработчики "startup" и "activate" и показывает окно.
- Второй `./a.out` снова вызывает приложение, и созданный экземпляр является удаленным.
Он не испускает сигнал "startup".
И он активирует приложение, но сигнал "activate" испускается на первичном экземпляре.
Удаленный экземпляр завершается.
- Первичный экземпляр вызвал обработчик "activate".
Обработчик создает новое окно.
Он добавляет панель меню к окну с помощью функции `gtk_application_window_set_show_menubar`.

Оба окна имеют панели меню.
И они точно одинаковые.
Оба окна принадлежат первичному экземпляру.

Если вы кликнете на меню "Quit", приложение (первичный экземпляр) завершится.

![menu1 -- two windows](../image/menu1_two_windows.png){width=12cm height=7cm}

Второе выполнение создает новое окно.
Однако это зависит от обработчика "activate".
Если вы создаете окно в обработчике startup, а обработчик activate просто представляет окно, при втором выполнении новое окно не создается.
Например, tfe (текстовый редактор файлов) не создает второе окно.
Он просто создает новую страницу блокнота.
Потому что его обработчик activate не создает никаких окон, а просто создает новую страницу блокнота.

Второе или более выполнений часто происходит в настольных приложениях.
Если вы дважды или более раз дважды щелкнете по иконке, приложение запустится несколько раз.
Поэтому вам нужно тщательно продумать свои обработчики startup и activate (open).
