# Система сборки

## Управление большими исходными файлами

До сих пор мы компилировали небольшой редактор.
Программа пока не сложная, но если она станет больше, её будет трудно поддерживать.
Поэтому нам следует сделать следующее сейчас.

- У нас был только один исходный файл C, и мы поместили всё в него.
Нам нужно разделить и организовать его.
- Есть два компилятора, `gcc` и `glib-compile-resources`.
Мы должны управлять ими с помощью одного инструмента сборки.

## Разделение исходного файла C на две части.

Когда вы разделяете исходный файл C на несколько частей, каждый файл должен содержать одну вещь.
Например, наш исходный код имеет две вещи: определение TfeTextView и функции, связанные с GtkApplication и GtkApplicationWindow.
Хорошая идея — разделить их на два файла, `tfetextview.c` и `tfe.c`.

- `tfetextview.c` включает определение и функции TfeTextView.
- `tfe.c` включает функции типа `main`, `app_activate`, `app_open` и так далее, которые относятся к GtkApplication и GtkApplicationWindow.

Теперь у нас есть три исходных файла: `tfetextview.c`, `tfe.c` и `tfe3.ui`.
Цифра `3` в `tfe3.ui` похожа на номер версии.
Управление версиями с помощью имён файлов — одна из возможных идей, но у неё также есть проблема.
Вам нужно переписывать имя файла в каждой версии, и это влияет на содержимое исходных файлов, которые ссылаются на имена файлов.
Поэтому мы должны убрать `3` из имени файла.

В `tfe.c` функция `tfe_text_view_new` вызывается для создания экземпляра TfeTextView.
Но она определена в `tfetextview.c`, а не в `tfe.c`.
Отсутствие объявления (не определения) `tfe_text_view_new` вызывает ошибку при компиляции `tfe.c`.
Объявление необходимо в `tfe.c`.
Эта публичная информация обычно записывается в заголовочные файлы.
Они имеют суффикс `.h`, например `tfetextview.h`.
Заголовочные файлы включаются в исходные файлы C.
Например, `tfetextview.h` включается в `tfe.c`.

Исходные файлы показаны ниже.

`tfetextview.h`

@@@include
tfe4/tfetextview.h
@@@

`tfetextview.c`

@@@include
tfe4/tfetextview.c
@@@

`tfe.c`

@@@include
tfe4/tfe.c
@@@

UI-файл `tfe.ui` такой же, как `tfe3.ui` в предыдущем разделе.

`tfe.gresource.xml`

@@@include
tfe4/tfe.gresource.xml
@@@

Разделение файла облегчает поддержку.
Но теперь мы сталкиваемся с новой проблемой.
Количество шагов сборки увеличилось.

- Компиляция ui-файла `tfe.ui` в `resources.c`.
- Компиляция `tfe.c` в `tfe.o` (объектный файл).
- Компиляция `tfetextview.c` в `tfetextview.o`.
- Компиляция `resources.c` в `resources.o`.
- Компоновка всех объектных файлов в приложение `tfe`.

Инструменты сборки управляют этими шагами.

## Meson и Ninja

Я объясню инструменты сборки Meson и Ninja.

Другие возможные инструменты — Make и Autotools.
Это традиционные инструменты, но они медленнее, чем Ninja.
Поэтому многие разработчики в последнее время переключились на Meson и Ninja.
Например, GTK 4 использует их.

Сначала вам нужно создать файл `meson.build`.

@@@include
tfe4/meson.build
@@@

- 1: функция `project` определяет вещи о проекте.
Первый аргумент — это имя проекта, а второй — язык программирования.
- 3: функция `dependency` определяет зависимость, которая берётся с помощью `pkg-config`.
Мы помещаем `gtk4` в качестве аргумента.
- 5: функция `import` импортирует модуль.
В строке 5 импортируется модуль gnome и присваивается переменной `gnome`.
Модуль gnome предоставляет вспомогательные инструменты для построения программ GTK.
- 6: метод `.compile_resources` из модуля gnome.
Он компилирует файлы в ресурсы, как указано в xml-файле.
В строке 6 имя файла ресурса — `resources`, что означает `resources.c` и `resources.h`, а xml-файл — `tfe.gresource.xml`.
Этот метод по умолчанию генерирует исходный файл C.
- 8: определяет исходные файлы.
- 10: функция `executable` генерирует целевой файл путём компиляции исходных файлов.
Первый аргумент — это имя файла цели. Следующие аргументы — исходные файлы.
Последние два аргумента имеют ключи и значения.
Например, четвёртый аргумент имеет ключ `dependencies`, разделитель (`:`) и значение `gtkdep`.
Этот тип параметра называется *ключевым параметром* или *kwargs*.
Значение `gtkdep` определено в строке 3.
Последний аргумент сообщает Meson и Ninja, что этот проект не должен устанавливать исполняемый файл.
Поэтому он просто компилируется в каталоге сборки.

Теперь запустите meson и ninja.

    $ meson setup _build
    $ ninja -C _build

meson имеет два аргумента.

- setup: первый аргумент — это команда meson.
Setup является значением по умолчанию, поэтому вы можете его опустить.
Но рекомендуется писать его явно начиная с версии 0.64.0.
- Второй аргумент — это имя каталога сборки.

Затем исполняемый файл `tfe` генерируется в каталоге `_build`.

    $ _build/tfe tfe.c tfetextview.c

Появляется окно.
Оно включает блокнот с двумя страницами.
Одна — `tfe.c`, а другая — `tfetextview.c`.

Для получения дополнительной информации см. [The Meson Build system](https://mesonbuild.com/).
