# Виджеты (3)

## Сигнал open

### Флаг G\_APPLICATION\_HANDLES\_OPEN

В предыдущем разделе мы создали очень простой редактор с использованием GtkTextView, GtkTextBuffer и GtkScrolledWindow.
Мы добавим в программу возможность чтения файлов и улучшим её до программы просмотра файлов.

Самый простой способ передать имя файла — использовать аргумент командной строки.

~~~
$ ./a.out filename
~~~

Программа откроет файл и вставит его содержимое в GtkTextBuffer.

Для этого нам нужно знать, как GtkApplication (или GApplication) распознаёт аргументы.
Это описано в [GIO API Reference -- Application](https://docs.gtk.org/gio/class.Application.html).

При создании GtkApplication в качестве аргумента передаётся флаг (GApplicationFlags).

~~~C
GtkApplication *
gtk_application_new (const gchar *application_id, GApplicationFlags flags);
~~~

В этом учебнике объясняются только два флага: `G_APPLICATION_DEFAULT_FLAGS` и `G_APPLICATION_HANDLES_OPEN`.

Флаг `G_APPLICATION_FLAGS_NONE` использовался вместо `G_APPLICATION_DEFAULT_FLAGS` до версии GIO 2.73.3 (GLib 2.73.3 от 5 августа 2022 года).
Теперь он устарел, и рекомендуется использовать `G_APPLICATION_DEFAULT_FLAGS`.

Для получения дополнительной информации см. [GIO API Reference -- ApplicationFlags](https://docs.gtk.org/gio/flags.ApplicationFlags.html) и
[GIO API Reference -- g\_application\_run](https://docs.gtk.org/gio/method.Application.run.html).

Мы уже использовали `G_APPLICATION_DEFAULT_FLAGS`, так как это самый простой вариант, и аргументы командной строки не разрешены.
Если вы передадите аргументы, произойдёт ошибка.

Флаг `G_APPLICATION_HANDLES_OPEN` — это второй по простоте вариант.
Он разрешает аргументы, но только имена файлов.

~~~C
app = gtk_application_new ("com.github.ToshioCP.tfv3", G_APPLICATION_HANDLES_OPEN);
~~~

### Сигнал open

Когда приложению передаётся флаг `G_APPLICATION_HANDLES_OPEN`, становятся доступны два сигнала.

- Сигнал activate: этот сигнал испускается, когда нет аргументов.
- Сигнал open: этот сигнал испускается, когда есть хотя бы один аргумент.

Обработчик сигнала "open" определяется следующим образом.

~~~C
void
open (
  GApplication* self,
  gpointer files,
  gint n_files,
  gchar* hint,
  gpointer user_data
)
~~~

Параметры:

- self: экземпляр приложения (обычно GtkApplication)
- files: массив GFile. [array length=n\_files] [element-type GFile]
- n_files: количество элементов в `files`
- hint: подсказка, предоставленная вызывающим экземпляром (обычно может быть проигнорирована)
- user_data: пользовательские данные, которые устанавливаются при подключении обработчика сигнала.

## Программа просмотра файлов

### Что такое программа просмотра файлов?

Программа просмотра файлов — это программа, которая отображает текстовые файлы.
Наша программа просмотра файлов работает следующим образом.

- Когда передаются аргументы, она распознаёт первый аргумент как имя файла и открывает его.
- Второй и последующие аргументы игнорируются.
- Если нет аргументов, она показывает сообщение об ошибке и завершает работу.
- Если файл успешно открыт, она читает содержимое файла, вставляет его в GtkTextBuffer и показывает окно.
- Если не удаётся открыть файл, она показывает сообщение об ошибке и завершает работу.

Программа показана ниже.

@@@include
tfv/tfv3.c
@@@

Сохраните её как `tfv3.c`.
Если вы скачали этот репозиторий, файл находится в `src/tfv/tfv3.c`.
Скомпилируйте и запустите.

~~~
$ comp tfv3
$ ./a.out tfv3.c
~~~

![File viewer](../image/screenshot_tfv3.png){width=6.3cm height=5.325cm}

Функция `main` имеет только два изменения по сравнению с предыдущей версией.

- `G_APPLICATION_DEFAULT_FLAGS` заменён на `G_APPLICATION_HANDLES_OPEN`
- Добавлено `g_signal_connect (app, "open", G_CALLBACK (app_open), NULL)`.

Когда функции `gtk_application_new` передаётся флаг `G_APPLICATION_HANDLES_OPEN`, приложение ведёт себя следующим образом:

- Если приложение запускается без аргументов командной строки, оно испускает сигнал "activate" при активации.
- Если приложение запускается с аргументами командной строки, оно испускает сигнал "open" при активации.

Обработчик `app_activate` становится очень простым.
Он просто выводит сообщение об ошибке и возвращается к вызывающей стороне.
Затем приложение немедленно завершает работу, потому что окно не создаётся.

Основная работа выполняется в обработчике `app_open`.

- Создаёт GtkApplicationWindow, GtkScrolledWindow, GtkTextView и GtkTextBuffer и соединяет их вместе
- Устанавливает режим переноса слов в `GTK_WRAP_WORD_CHAR` в GtktextView
- Устанавливает GtkTextView как нередактируемый, потому что программа не редактор, а только просмотрщик
- Читает файл и вставляет текст в GtkTextBuffer (это будет объяснено позже)
- Если файл не открывается, выводит сообщение об ошибке и уничтожает окно. Это приводит к завершению работы приложения.

Ниже приведена часть программы для чтения файла.

~~~C
if (g_file_load_contents (files[0], NULL, &contents, &length, NULL, &err)) {
  gtk_text_buffer_set_text (tb, contents, length);
  g_free (contents);
  if ((filename = g_file_get_basename (files[0])) != NULL) {
    gtk_window_set_title (GTK_WINDOW (win), filename);
    g_free (filename);
  }
  gtk_window_present (GTK_WINDOW (win));
} else {
  g_printerr ("%s.\n", err->message);
  g_error_free (err);
  gtk_window_destroy (GTK_WINDOW (win));
}
~~~

Функция `g_file_load_contents` загружает содержимое файла во временный буфер,
который автоматически выделяется, и устанавливает `contents` для указания на буфер.
Длина буфера присваивается переменной `length`.
Она возвращает `TRUE`, если содержимое файла успешно загружено.
Если возникает ошибка, она возвращает `FALSE` и устанавливает переменную `err` для указания на вновь созданную структуру GError.
Вызывающая сторона становится владельцем структуры GError и отвечает за её освобождение.
Если вы хотите узнать подробности о g\_file\_load\_contents, см. [g file load contents](https://docs.gtk.org/gio/method.File.load_contents.html).

Если файл успешно прочитан, программа вставляет содержимое в GtkTextBuffer,
освобождает временный буфер, на который указывает `contents`, устанавливает заголовок окна,
освобождает память, на которую указывает `filename`, а затем показывает окно.

Если чтение не удаётся, `g_file_load_contents` устанавливает `err` для указания на вновь созданную структуру GError.
Структура имеет вид:

~~~C
struct GError {
  GQuark domain;
  int code;
  char* message;
}
~~~

Элемент `message` используется чаще всего.
Он указывает на сообщение об ошибке.
Функция `g_error_free` используется для освобождения памяти структуры.
См. [GError](https://docs.gtk.org/glib/struct.Error.html).

Приведённая выше программа выводит сообщение об ошибке, освобождает `err`, уничтожает окно и, наконец, завершает работу программы.

## GtkNotebook

GtkNotebook — это виджет-контейнер, который содержит несколько виджетов с вкладками.
Он показывает только один дочерний виджет за раз.
Другой дочерний виджет будет показан при щелчке по его вкладке.

![GtkNotebook](../image/screenshot_gtk_notebook.png){width=13.2cm height=5.325cm}

Левое изображение — это окно при запуске.
Показан файл `pr1.c`, и его имя находится на левой вкладке.
После щелчка по правой вкладке показывается содержимое файла `tfv1.c` (правое изображение).

Ниже приведён `tfv4.c`.
Он имеет виджет GtkNoteBook.
Он вставляется как дочерний элемент GtkApplicationWindow и содержит несколько GtkScrolledWindow.

@@@include
tfv/tfv4.c
@@@

Большинство изменений находятся в функции `app_open`.
Числа слева от следующих элементов — это номера строк в исходном коде.

- 11-13: определяются переменные `nb`, `lab` и `nbp`. Они указывают соответственно на GtkNotebook, GtkLabel и GtkNotebookPage.
- 24: заголовок окна устанавливается на "file viewer".
- 25: размер окна по умолчанию — 600x400.
- 26-27: создаётся GtkNotebook и вставляется в GtkApplicationWindow как дочерний элемент.
- 29-57: цикл for. Переменная `files[i]` указывает на i-й GFile, который создаётся GtkApplication из i-го аргумента командной строки.
- 31-36: создаются GtkScrollledWindow, GtkTextView. GtkTextBuffer получается из GtkTextView.
GtkTextView подключается к GtkScrolledWindow как дочерний элемент.
- 38-39: вставляет содержимое файла в GtkTextBuffer и освобождает память, на которую указывает `contents`.
- 40-42: если имя файла взято из GFile, создаётся GtkLabel с именем файла. Строка `filename` освобождается.
- 43-44: если не удаётся получить имя файла, создаётся GtkLabel с пустой строкой.
- 45-46: добавляет GtkScrolledWindow к GtkNotebook в качестве дочернего элемента.
И GtkLabel устанавливается как вкладка дочернего элемента.
При этом автоматически создаётся GtkNoteBookPage.
Функция `gtk_notebook_get_page` возвращает GtkNotebookPage дочернего элемента (GtkScrolledWindow).
- 47: GtkNotebookPage имеет свойство "tab-expand".
Если оно установлено в TRUE, то вкладка расширяется по горизонтали настолько, насколько это возможно.
Если оно установлено в FALSE, ширина вкладки определяется размером метки.
`g_object_set` — это общая функция для установки свойств объектов.
См. [GObject API Reference -- g\_object\_set](https://docs.gtk.org/gobject/method.Object.set.html).
- 48-50: если не удаётся прочитать файл, показывается сообщение об ошибке.
Функция `g_clear_error (&err)` работает как `g_error_free (err); err = NULL`.
- 53-56: если существует хотя бы одна страница, окно показывается.
В противном случае окно уничтожается, и приложение завершает работу.
